// Code templates for generated files

export const generateImports = () => `// Auto-generated API client
// Generated at: ${new Date().toISOString()}
// DO NOT EDIT THIS FILE MANUALLY

export class ApiError extends Error {
  constructor(
    public status: number,
    message: string,
    public data?: any,
  ) {
    super(message);
    this.name = "ApiError";
  }
}

export interface ApiRequestOptions extends Omit<RequestInit, "body" | "method"> {
  baseUrl?: string;
}

async function request<T>(
  path: string,
  options?: RequestInit & { baseUrl?: string }
): Promise<T> {
  const { baseUrl, ...init } = options || {};
  const url = baseUrl ? \`\${baseUrl}\${path}\` : path;
  
  const response = await fetch(url, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      ...(init?.headers as any),
    },
  });

  if (!response.ok) {
    let errorData: any;
    try {
      errorData = await response.json();
    } catch {
      errorData = await response.text();
    }
    throw new ApiError(
      response.status,
      errorData?.message || response.statusText,
      errorData
    );
  }

  if (response.status === 204) {
    return null as T;
  }

  const text = await response.text();
  if (!text) {
    return null as T;
  }

  try {
    return JSON.parse(text);
  } catch {
    return text as T;
  }
}

// Apply default values to request data
function applyDefaults<T extends Record<string, any>>(
  data: T,
  defaults: Record<string, any>
): T {
  const result = { ...data };
  
  for (const [key, defaultValue] of Object.entries(defaults)) {
    if (result[key] === undefined && defaultValue !== undefined) {
      (result as any)[key] = defaultValue;
    }
  }
  
  return result;
}`;

export const generateHookImports = () => `// Auto-generated React Query hooks
// Generated at: ${new Date().toISOString()}
// DO NOT EDIT THIS FILE MANUALLY

import {
  useMutation,
  useQuery,
  useQueryClient,
  type UseMutationOptions,
  type UseQueryOptions,
} from "@tanstack/react-query";
import { apiClient, type ApiError } from "./client";
import type * as Types from "./client";`;

export const generateUsageExamples = () => `/**
 * Usage Examples:
 * 
 * // List resources
 * const { data: tasks } = useTasks();
 * 
 * // Get single resource
 * const { data: task } = useTask(taskId);
 * 
 * // Create resource
 * const createMutation = useCreateTask();
 * await createMutation.mutateAsync({ name: "New Task" });
 * 
 * // Update resource
 * const updateMutation = useUpdateTask();
 * await updateMutation.mutateAsync(taskId, { done: true });
 * 
 * // Delete resource
 * const deleteMutation = useDeleteTask();
 * await deleteMutation.mutateAsync(taskId);
 * 
 * // With custom options
 * const { data } = useTasks({
 *   staleTime: 5 * 60 * 1000, // 5 minutes
 *   refetchInterval: 30 * 1000, // 30 seconds
 * });
 */`;

export const generateUtilityHooks = () => `// Utility hooks for common endpoints
export const useHealthCheck = (
  options?: Omit<UseQueryOptions<any, ApiError>, "queryKey" | "queryFn">,
) => {
  return useQuery({
    queryKey: ["health"],
    queryFn: () => apiClient.health?.list?.() || fetch("/api/health").then(r => r.json()),
    ...options,
  });
};

export const useMe = (
  options?: Omit<UseQueryOptions<any, ApiError>, "queryKey" | "queryFn">,
) => {
  return useQuery({
    queryKey: ["me"],
    queryFn: () => apiClient.me?.list?.() || fetch("/api/me").then(r => r.json()),
    ...options,
  });
};`;

export const generateQueryKeyFactory = (
	resourceName: string,
) => `export const ${resourceName}Keys = {
  all: ['${resourceName}'] as const,
  lists: () => [...${resourceName}Keys.all, 'list'] as const,
  list: (query?: Record<string, any>) => [...${resourceName}Keys.lists(), { query }] as const,
  details: () => [...${resourceName}Keys.all, 'detail'] as const,
  detail: (id: unknown) => [...${resourceName}Keys.details(), id] as const,
};`;

export const generateMockGenerator = (
	resourceName: string,
	resourceType: string,
) => {
	const singular = resourceName.endsWith("s")
		? resourceName.slice(0, -1)
		: resourceName;
	const capitalizedSingular =
		singular.charAt(0).toUpperCase() + singular.slice(1);

	return `export function mock${capitalizedSingular}(overrides?: Partial<${resourceType}>): ${resourceType} {
  return {
    id: Math.floor(Math.random() * 10000),
    // Add more default values based on schema
    ...overrides
  } as ${resourceType};
}`;
};

export const generateCreateApiClientFunction =
	() => `// Create client with custom options
export function createApiClient(defaultOptions?: ApiRequestOptions) {
  return new Proxy(apiClient as any, {
    get(target, prop) {
      const resource = target[prop as keyof typeof target];
      if (!resource) return undefined;
      
      return new Proxy(resource as any, {
        get(resourceTarget, methodProp) {
          const method = resourceTarget[methodProp as keyof typeof resourceTarget];
          if (typeof method !== 'function') return method;
          
          return (...args: any[]) => {
            const lastArg = args[args.length - 1];
            const isOptions = lastArg && typeof lastArg === 'object' && 'baseUrl' in lastArg;
            
            if (isOptions) {
              args[args.length - 1] = { ...defaultOptions, ...lastArg };
            } else {
              args.push(defaultOptions);
            }
            
            return (method as any).apply(resourceTarget, args);
          };
        }
      });
    }
  }) as typeof apiClient;
}`;

export const generateResourceTypes =
	() => `// Task types for backward compatibility
export type Task = {
  id: number;
  name: string;
  done: boolean;
  createdAt: string | null;
  updatedAt: string | null;
};

export type NewTask = {
  name: string;
  done?: boolean;
};

export type PatchTask = Partial<NewTask>;`;
