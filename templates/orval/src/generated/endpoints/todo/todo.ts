/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Vinoflare API
 * REST API for Vinoflare application
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetTodo200,
  GetTodoId200,
  PostTodo201,
  PostTodoBody,
  PutTodoId200,
  PutTodoIdBody
} from '../../schemas';

import { customFetch } from '../../../client/lib/custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieves a list of all todo
 * @summary Get all todo
 */
export type getTodoResponse200 = {
  data: GetTodo200
  status: 200
}
    
export type getTodoResponseComposite = getTodoResponse200;
    
export type getTodoResponse = getTodoResponseComposite & {
  headers: Headers;
}

export const getGetTodoUrl = () => {


  

  return `/api/todo`
}

export const getTodo = async ( options?: RequestInit): Promise<getTodoResponse> => {
  
  return customFetch<getTodoResponse>(getGetTodoUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTodoQueryKey = () => {
    return [`/api/todo`] as const;
    }

    
export const getGetTodoQueryOptions = <TData = Awaited<ReturnType<typeof getTodo>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTodoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodo>>> = ({ signal }) => getTodo({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTodoQueryResult = NonNullable<Awaited<ReturnType<typeof getTodo>>>
export type GetTodoQueryError = unknown


export function useGetTodo<TData = Awaited<ReturnType<typeof getTodo>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodo>>,
          TError,
          Awaited<ReturnType<typeof getTodo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodo<TData = Awaited<ReturnType<typeof getTodo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodo>>,
          TError,
          Awaited<ReturnType<typeof getTodo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodo<TData = Awaited<ReturnType<typeof getTodo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all todo
 */

export function useGetTodo<TData = Awaited<ReturnType<typeof getTodo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTodoQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Creates a new todo with the provided data
 * @summary Create new todo
 */
export type postTodoResponse201 = {
  data: PostTodo201
  status: 201
}

export type postTodoResponse400 = {
  data: void
  status: 400
}
    
export type postTodoResponseComposite = postTodoResponse201 | postTodoResponse400;
    
export type postTodoResponse = postTodoResponseComposite & {
  headers: Headers;
}

export const getPostTodoUrl = () => {


  

  return `/api/todo`
}

export const postTodo = async (postTodoBody: PostTodoBody, options?: RequestInit): Promise<postTodoResponse> => {
  
  return customFetch<postTodoResponse>(getPostTodoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postTodoBody,)
  }
);}




export const getPostTodoMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTodo>>, TError,{data: PostTodoBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTodo>>, TError,{data: PostTodoBody}, TContext> => {

const mutationKey = ['postTodo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTodo>>, {data: PostTodoBody}> = (props) => {
          const {data} = props ?? {};

          return  postTodo(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostTodoMutationResult = NonNullable<Awaited<ReturnType<typeof postTodo>>>
    export type PostTodoMutationBody = PostTodoBody
    export type PostTodoMutationError = void

    /**
 * @summary Create new todo
 */
export const usePostTodo = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTodo>>, TError,{data: PostTodoBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTodo>>,
        TError,
        {data: PostTodoBody},
        TContext
      > => {

      const mutationOptions = getPostTodoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Retrieves a specific todo by its ID
 * @summary Get todo by ID
 */
export type getTodoIdResponse200 = {
  data: GetTodoId200
  status: 200
}

export type getTodoIdResponse404 = {
  data: void
  status: 404
}
    
export type getTodoIdResponseComposite = getTodoIdResponse200 | getTodoIdResponse404;
    
export type getTodoIdResponse = getTodoIdResponseComposite & {
  headers: Headers;
}

export const getGetTodoIdUrl = (id: number,) => {


  

  return `/api/todo/${id}`
}

export const getTodoId = async (id: number, options?: RequestInit): Promise<getTodoIdResponse> => {
  
  return customFetch<getTodoIdResponse>(getGetTodoIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTodoIdQueryKey = (id: number,) => {
    return [`/api/todo/${id}`] as const;
    }

    
export const getGetTodoIdQueryOptions = <TData = Awaited<ReturnType<typeof getTodoId>>, TError = void>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTodoIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodoId>>> = ({ signal }) => getTodoId(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTodoId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTodoIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTodoId>>>
export type GetTodoIdQueryError = void


export function useGetTodoId<TData = Awaited<ReturnType<typeof getTodoId>>, TError = void>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodoId>>,
          TError,
          Awaited<ReturnType<typeof getTodoId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodoId<TData = Awaited<ReturnType<typeof getTodoId>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodoId>>,
          TError,
          Awaited<ReturnType<typeof getTodoId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodoId<TData = Awaited<ReturnType<typeof getTodoId>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get todo by ID
 */

export function useGetTodoId<TData = Awaited<ReturnType<typeof getTodoId>>, TError = void>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTodoIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Updates an existing todo
 * @summary Update todo
 */
export type putTodoIdResponse200 = {
  data: PutTodoId200
  status: 200
}

export type putTodoIdResponse404 = {
  data: void
  status: 404
}
    
export type putTodoIdResponseComposite = putTodoIdResponse200 | putTodoIdResponse404;
    
export type putTodoIdResponse = putTodoIdResponseComposite & {
  headers: Headers;
}

export const getPutTodoIdUrl = (id: number,) => {


  

  return `/api/todo/${id}`
}

export const putTodoId = async (id: number,
    putTodoIdBody: PutTodoIdBody, options?: RequestInit): Promise<putTodoIdResponse> => {
  
  return customFetch<putTodoIdResponse>(getPutTodoIdUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putTodoIdBody,)
  }
);}




export const getPutTodoIdMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putTodoId>>, TError,{id: number;data: PutTodoIdBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putTodoId>>, TError,{id: number;data: PutTodoIdBody}, TContext> => {

const mutationKey = ['putTodoId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putTodoId>>, {id: number;data: PutTodoIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putTodoId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutTodoIdMutationResult = NonNullable<Awaited<ReturnType<typeof putTodoId>>>
    export type PutTodoIdMutationBody = PutTodoIdBody
    export type PutTodoIdMutationError = void

    /**
 * @summary Update todo
 */
export const usePutTodoId = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putTodoId>>, TError,{id: number;data: PutTodoIdBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putTodoId>>,
        TError,
        {id: number;data: PutTodoIdBody},
        TContext
      > => {

      const mutationOptions = getPutTodoIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Deletes a todo by ID
 * @summary Delete todo
 */
export type deleteTodoIdResponse204 = {
  data: void
  status: 204
}

export type deleteTodoIdResponse404 = {
  data: void
  status: 404
}
    
export type deleteTodoIdResponseComposite = deleteTodoIdResponse204 | deleteTodoIdResponse404;
    
export type deleteTodoIdResponse = deleteTodoIdResponseComposite & {
  headers: Headers;
}

export const getDeleteTodoIdUrl = (id: number,) => {


  

  return `/api/todo/${id}`
}

export const deleteTodoId = async (id: number, options?: RequestInit): Promise<deleteTodoIdResponse> => {
  
  return customFetch<deleteTodoIdResponse>(getDeleteTodoIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTodoIdMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTodoId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTodoId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteTodoId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTodoId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteTodoId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTodoIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTodoId>>>
    
    export type DeleteTodoIdMutationError = void

    /**
 * @summary Delete todo
 */
export const useDeleteTodoId = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTodoId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTodoId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteTodoIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    