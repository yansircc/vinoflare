// Auto-generated API client
// Generated at: 2025-06-23T06:00:58.038Z
// DO NOT EDIT THIS FILE MANUALLY

export class ApiError extends Error {
	constructor(
		public status: number,
		message: string,
		public data?: any,
	) {
		super(message);
		this.name = "ApiError";
	}
}

export interface ApiRequestOptions
	extends Omit<RequestInit, "body" | "method"> {
	baseUrl?: string;
}

async function request<T>(
	path: string,
	options?: RequestInit & { baseUrl?: string },
): Promise<T> {
	const { baseUrl, ...init } = options || {};
	const url = baseUrl ? `${baseUrl}${path}` : path;

	const response = await fetch(url, {
		...init,
		headers: {
			"Content-Type": "application/json",
			...(init?.headers as any),
		},
	});

	if (!response.ok) {
		let errorData: any;
		try {
			errorData = await response.json();
		} catch {
			errorData = await response.text();
		}
		throw new ApiError(
			response.status,
			errorData?.message || response.statusText,
			errorData,
		);
	}

	if (response.status === 204) {
		return null as T;
	}

	const text = await response.text();
	if (!text) {
		return null as T;
	}

	try {
		return JSON.parse(text);
	} catch {
		return text as T;
	}
}

// Apply default values to request data
function applyDefaults<T extends Record<string, any>>(
	data: T,
	defaults: Record<string, any>,
): T {
	const result = { ...data };

	for (const [key, defaultValue] of Object.entries(defaults)) {
		if (result[key] === undefined && defaultValue !== undefined) {
			(result as any)[key] = defaultValue;
		}
	}

	return result;
}

// Type definitions

// Resource-specific types
// Task types for backward compatibility
export type Task = {
	id: number;
	name: string;
	done: boolean;
	createdAt: string | null;
	updatedAt: string | null;
};

export type NewTask = {
	name: string;
	done?: boolean;
};

export type PatchTask = Partial<NewTask>;

// Query key factories
export const apiKeys = {
	all: ["api"] as const,
	lists: () => [...apiKeys.all, "list"] as const,
	list: (query?: Record<string, any>) =>
		[...apiKeys.lists(), { query }] as const,
	details: () => [...apiKeys.all, "detail"] as const,
	detail: (id: unknown) => [...apiKeys.details(), id] as const,
};

export const healthKeys = {
	all: ["health"] as const,
	lists: () => [...healthKeys.all, "list"] as const,
	list: (query?: Record<string, any>) =>
		[...healthKeys.lists(), { query }] as const,
	details: () => [...healthKeys.all, "detail"] as const,
	detail: (id: unknown) => [...healthKeys.details(), id] as const,
};

export const meKeys = {
	all: ["me"] as const,
	lists: () => [...meKeys.all, "list"] as const,
	list: (query?: Record<string, any>) =>
		[...meKeys.lists(), { query }] as const,
	details: () => [...meKeys.all, "detail"] as const,
	detail: (id: unknown) => [...meKeys.details(), id] as const,
};

export const tasksKeys = {
	all: ["tasks"] as const,
	lists: () => [...tasksKeys.all, "list"] as const,
	list: (query?: Record<string, any>) =>
		[...tasksKeys.lists(), { query }] as const,
	details: () => [...tasksKeys.all, "detail"] as const,
	detail: (id: unknown) => [...tasksKeys.details(), id] as const,
};

// Mock data generators
export function mockTask(
	overrides?: Partial<{
		id: number;
		name: string;
		done: boolean;
		createdAt: string | null;
		updatedAt: string | null;
	}>,
): {
	id: number;
	name: string;
	done: boolean;
	createdAt: string | null;
	updatedAt: string | null;
} {
	return {
		id: Math.floor(Math.random() * 10000),
		// Add more default values based on schema
		...overrides,
	} as {
		id: number;
		name: string;
		done: boolean;
		createdAt: string | null;
		updatedAt: string | null;
	};
}

// API Client
export const apiClient = {
	api: {
		/**
		 * API
		 */
		list: async (
			options?: ApiRequestOptions,
		): Promise<{
			name: string;
			version: string;
			description: string;
			endpoints: {
				tasks: string;
				health: string;
				me: string;
			};
			timestamp: string;
		}> => {
			return request<{
				name: string;
				version: string;
				description: string;
				endpoints: {
					tasks: string;
					health: string;
					me: string;
				};
				timestamp: string;
			}>("/api", {
				method: "GET",
				...options,
			});
		},
	},
	health: {
		/**
		 * Health
		 */
		list: async (
			options?: ApiRequestOptions,
		): Promise<{
			status: string;
			timestamp: string;
			version: string;
			environment: string;
		}> => {
			return request<{
				status: string;
				timestamp: string;
				version: string;
				environment: string;
			}>("/api/health", {
				method: "GET",
				...options,
			});
		},
	},
	me: {
		/**
		 * Get me
		 */
		list: async (
			options?: ApiRequestOptions,
		): Promise<{
			user: {
				id: string;
				name: string;
				email: string;
				emailVerified: boolean;
				image: string | null;
				createdAt: string;
				updatedAt: string;
			} | null;
			session: {
				id: string;
				userId: string;
				userAgent: string | null;
				ipAddress: string | null;
				expiresAt: string;
				createdAt: string;
				updatedAt: string;
			} | null;
		}> => {
			return request<{
				user: {
					id: string;
					name: string;
					email: string;
					emailVerified: boolean;
					image: string | null;
					createdAt: string;
					updatedAt: string;
				} | null;
				session: {
					id: string;
					userId: string;
					userAgent: string | null;
					ipAddress: string | null;
					expiresAt: string;
					createdAt: string;
					updatedAt: string;
				} | null;
			}>("/api/me", {
				method: "GET",
				...options,
			});
		},
	},
	tasks: {
		list: async (
			options?: ApiRequestOptions,
		): Promise<
			Array<{
				id: number;
				name: string;
				done: boolean;
				createdAt: string | null;
				updatedAt: string | null;
			}>
		> => {
			return request<
				Array<{
					id: number;
					name: string;
					done: boolean;
					createdAt: string | null;
					updatedAt: string | null;
				}>
			>("/api/tasks", {
				method: "GET",
				...options,
			});
		},
		create: async (
			data: {
				name: string;
				done: boolean;
			},
			options?: ApiRequestOptions,
		): Promise<{
			id: number;
			name: string;
			done: boolean;
			createdAt: string | null;
			updatedAt: string | null;
		}> => {
			return request<{
				id: number;
				name: string;
				done: boolean;
				createdAt: string | null;
				updatedAt: string | null;
			}>("/api/tasks", {
				method: "POST",
				body: JSON.stringify(data),
				...options,
			});
		},
		getById: async (
			id: string | number,
			options?: ApiRequestOptions,
		): Promise<{
			id: number;
			name: string;
			done: boolean;
			createdAt: string | null;
			updatedAt: string | null;
		}> => {
			return request<{
				id: number;
				name: string;
				done: boolean;
				createdAt: string | null;
				updatedAt: string | null;
			}>(`/api/tasks/${id}`, {
				method: "GET",
				...options,
			});
		},
		update: async (
			id: string | number,
			data: {
				name?: string;
				done?: boolean;
			},
			options?: ApiRequestOptions,
		): Promise<{
			id: number;
			name: string;
			done: boolean;
			createdAt: string | null;
			updatedAt: string | null;
		}> => {
			return request<{
				id: number;
				name: string;
				done: boolean;
				createdAt: string | null;
				updatedAt: string | null;
			}>(`/api/tasks/${id}`, {
				method: "PATCH",
				body: JSON.stringify(data),
				...options,
			});
		},
		delete: async (
			id: string | number,
			options?: ApiRequestOptions,
		): Promise<void> => {
			return request<void>(`/api/tasks/${id}`, {
				method: "DELETE",
				...options,
			});
		},
	},
};

// Create client with custom options
export function createApiClient(defaultOptions?: ApiRequestOptions) {
	return new Proxy(apiClient as any, {
		get(target, prop) {
			const resource = target[prop as keyof typeof target];
			if (!resource) return undefined;

			return new Proxy(resource as any, {
				get(resourceTarget, methodProp) {
					const method =
						resourceTarget[methodProp as keyof typeof resourceTarget];
					if (typeof method !== "function") return method;

					return (...args: any[]) => {
						const lastArg = args[args.length - 1];
						const isOptions =
							lastArg && typeof lastArg === "object" && "baseUrl" in lastArg;

						if (isOptions) {
							args[args.length - 1] = { ...defaultOptions, ...lastArg };
						} else {
							args.push(defaultOptions);
						}

						return (method as any).apply(resourceTarget, args);
					};
				},
			});
		},
	}) as typeof apiClient;
}
